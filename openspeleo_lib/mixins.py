import json

from iteration_utilities import duplicates
from pydantic import Field
from pydantic import field_validator
from pydantic import model_validator

from openspeleo_lib.constants import COMPASS_MAX_NAME_LENGTH
from openspeleo_lib.errors import DuplicateValueError
from openspeleo_lib.generators import UniqueIDGenerator
from openspeleo_lib.generators import UniqueNameGenerator


class BaseMixin:
    @model_validator(mode="before")
    @classmethod
    def enforce_snake_and_remove_none(cls, data: dict) -> dict:
        return {k: v for k, v in data.items() if v is not None}

    def to_json(self) -> str:
        """
        Serialize the model to a JSON string with indentation and sorted keys.

        Returns:
            str: The JSON representation of the model.
        """
        return json.dumps(self.model_dump(), indent=4, sort_keys=True)

    # ======================== VALIDATOR UTILS ======================== #

    @classmethod
    def validate_unique(cls, field: str, values: list) -> list:
        vals2check = [getattr(val, field) for val in values]
        dupl_vals = list(duplicates(vals2check))
        if dupl_vals:
            raise DuplicateValueError(
                f"[{cls.__name__}] Duplicate value found for `{field}`: {dupl_vals}"
            )
        return values


class AutoIdModelMixin:
    id: int = Field(
        default_factory=lambda: UniqueIDGenerator.get(),
    )

    @field_validator("id", mode="before")
    @classmethod
    def validate_unique_id(cls, value: str | int | None) -> int:
        if value is None or value == "":
            return cls.id.default_factory()

        if isinstance(value, str):
            value = int(value)

        UniqueNameGenerator.register(value=value)
        return value


class NameIdModelMixin:
    name_compass: str = Field(
        default_factory=lambda: UniqueNameGenerator.get(str_len=6),
        min_length=2,
        max_length=COMPASS_MAX_NAME_LENGTH,
    )

    @field_validator("name_compass", mode="before")
    @classmethod
    def validate_unique_name_compass(cls, value: str | None) -> str:
        """Note: Validators are only ran with custom fed values.
        Not autogenerated ones. Hence we need to register the name."""

        if value is None or value == "":
            return cls.name_compass.default_factory()

        # 1. Verify the name is only composed of valid chars.
        for char in value:
            if char.upper() not in [
                *UniqueNameGenerator.VOCAB,
                *list("_-~:!?.'()[]{}@*&#%|$"),
            ]:
                raise ValueError(f"The character `{char}` is not allowed as `name`.")

        if len(value) > COMPASS_MAX_NAME_LENGTH:
            raise ValueError(
                f"Name {value} is too long, maximum allowed: {COMPASS_MAX_NAME_LENGTH}"
            )

        UniqueNameGenerator.register(value=value)
        return value
